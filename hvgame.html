<!DOCTYPE html>
<html>
<head>
  <title>Hidden Variables</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body, html {
        height: 100%;
        margin: 0;
        padding: 0;
        pointer-events: none; /* Disable all touch events on the image */
        touch-action: none; /* Disable touch gestures */
        user-select: none;
        -moz-user-select: none;
        -webkit-text-select: none;
        -webkit-user-select: none;
        background: none;
        overflow: hidden; /* Disable all scrolling */
    }

    .background {
        position: absolute;
        width: 100%;
        height: 100%;
    }

    .background video {
        position: absolute;
        top: 50%;
        left: 50%;
        min-width: 100vw;
        min-height: 100vh;
        width: auto;
        height: auto;
        transform: translate(-50%, -50%);
        z-index: 1;
        object-fit: cover;
    }


    .overlay-image {
        position: absolute;
        top: 0;
        left: 50%;
        width: 130vw;
        max-width: 900px;
        height: 150%;  
        background: url('hvgame.png') center top / 100% auto no-repeat;
        z-index: 3;
        transform: translate(-48%,-2%);
    }


    #gameContainer {
        width: 53%; 
        margin-left: 22%;
        margin-top: 38%; /* If original image height was 900px and original margin-top was 370px */
        position: relative;
        pointer-events: none;
        touch-action: none;
        user-select: none;
        -moz-user-select: none;
        -webkit-text-select: none;
        -webkit-user-select: none;
    }


    #gameCanvas {
        position: absolute;
        width: 100%;
        z-index: 4;
        pointer-events: none;
        touch-action: none;
        user-select: none;
        -moz-user-select: none;
        -webkit-text-select: none;
        -webkit-user-select: none;
    }

    #image {
    width: 100%;
    height: auto;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
    pointer-events: none; /* Disable all touch events on the image */
    touch-action: none; /* Disable touch gestures */
    user-select: none;
    -moz-user-select: none;
    -webkit-text-select: none;
    -webkit-user-select: none;
    }

    .black-square-contaniner {
        position: absolute;
        top: 0;
        left: 50%;
        width: 100%;
        max-width: 800px;
        max-height: 450px;
        height: 120%;  
    }

    .black-square {
        width: 75%; 
        margin-top: 30%; 
        margin-left: -35%;
        position: relative;
        height: 100%;
        background: black;
        z-index: 2; /* This will sit between the video and the overlay image */
    }

    .black-fade {
        width: 100%; 
        margin-top: 0%; 
        margin-left: 0%;
        position: absolute;
        height: 100%;
        background: black;
        z-index: 2; /* This will sit between the video and the overlay image */
        opacity: 36%;
        pointer-events: none; /* Disable all touch events on the image */
        touch-action: none; /* Disable touch gestures */
        user-select: none;
        -moz-user-select: none;
        -webkit-text-select: none;
        -webkit-user-select: none;
	    
    }


  </style>
</head>
<body>
    <div class="background">
        <video playsinline autoplay muted loop preload="auto">
            <source src="IMAGES/LASERS.mp4" type="video/mp4">
            Your browser does not support the video tag.
        </video>
        <div class="black-square-contaniner">
            <div class="black-square"></div> <!-- New div for the black square -->
        </div> <!-- New div for the black square -->
        <div class="black-fade"></div> <!-- New div for the black square -->
        <div class="overlay-image">
            <div id="gameContainer">
                <canvas id="gameCanvas" width="480" height="320"></canvas>
            </div>
        </div>
        <audio id="player" preload>
            <source src="hvgame/1_DICE.mp3" type="audio/mp3">
            Your browser does not support the audio element.
        </audio> 
    </div>  
     
<script type="module">

    // Mobile Checker

    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    console.log('Mobile: '+isMobile)

    // SFX

    var paddleHitSrc = "hvgame/paddleHit.mp3";
    var brickHitSrc = "hvgame/brickHit.mp3";
    var brickDestroySrc = "hvgame/brickDestroy.mp3";
    var lostLifeSrc = "hvgame/lostLife.mp3";

    async function playFX(fX,muteFX) {
        if (!isMobile && !muteAllFX) {
            var sound = new Audio(fX)
            if (!muteFX){
                sound.volume = 0.3;
                if (fX==brickDestroySrc) {
                    sound.volume = 0.2;
                }
                if (fX==lostLifeSrc) {
                    sound.volume=0.2;
                }
            } else {sound.volume = 0;}
            sound.play().catch(e => console.error('Error playing '+fX+' sound:', e));
        }
    }
    
    // Import the functions you need from the SDKs you need
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-app.js";
    import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/10.0.0/firebase-firestore.js";

    // Your web app's Firebase configuration
    const firebaseConfig = {
        apiKey: "AIzaSyApr_r_rEFmo_CxRmM3UapGW56eUybOsyc",
        authDomain: "hiddenvariables-393304.firebaseapp.com",
        projectId: "hiddenvariables-393304",
        storageBucket: "hiddenvariables-393304.appspot.com",
        messagingSenderId: "189667231661",
        appId: "1:189667231661:web:c702a1f213dfa6a3dcc324"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore();

    var playerName = "";
    var highScoreAddress = ""; // Variable to store the wallet address
    var score = 0;
    
    async function addScore() {
        await addDoc(collection(db, 'scores'), {
            name: playerName,
            score: parseInt(score),
            wallet: highScoreAddress,
        })

        // Add the score and name to the local arrays and sort
        topScores.push(score);
        topNames.push(playerName);
        sortTopScoresAndNames();

        // Update the high and low scores
        oldHighScore = topScores[0];  // The highest score in the array
        if (topScores.length == 10) {
            oldTopScore = topScores[9];  // The lowest score in the top 10
        } else {
            oldTopScore = 0; // still room left on the partly-empty top 10
        }
    }

    // Function to sort topScores and topNames arrays based on the scores
    function sortTopScoresAndNames() {
        let combined = [];
        for(let i = 0; i < topScores.length; i++) {
            combined.push({
                'score': topScores[i],
                'name': topNames[i]
            });
        }

        combined.sort((a, b) => b.score - a.score);

        for(let i = 0; i < combined.length; i++) {
            topScores[i] = combined[i].score;
            topNames[i] = combined[i].name;
        }
    }


    // GAME MODULE BEGINS BY GRABBING HIGH SCORES
    
    var oldHighScore;
    var oldTopScore;
    var topScores = [];
    var topNames = [];

    // Get and display top scores
    async function getTopScores() {
        const scoresQuery = query(collection(db, 'scores'), orderBy('score', 'desc'), limit(10));
        const scoresSnapshot = await getDocs(scoresQuery);
        topScores = [];  // Reset the array before populating it

        await scoresSnapshot.forEach((doc) => {
            const scoreData = doc.data();
            topScores.push(scoreData.score);  // Add the score to the array
            topNames.push(scoreData.name)
        });

        oldHighScore = topScores[0];  // The highest score in the array
        if (topScores.length == 10) {
            oldTopScore = topScores[9];  // The lowest score in the top 10
        } else {
            oldTopScore = 0; // still room left on the partly-empty top 10
        }

        console.log("Highest Score: " + oldHighScore);
        console.log("Lowest Score in Top 10: " + oldTopScore);
    }


    getTopScores();

    // GAME CODE BELOW 

    var devMode = false;
    let previousTime = Date.now();
    let currentTime, timeElapsed;
    var canvas = document.getElementById("gameCanvas");
    var ctx = canvas.getContext("2d");
    var ballRadius = 10;
    var ballShrink = 0.95;
    var paddleShrink = 0.8;
    var paddleHeight = 10;
    var paddleWidth = 150;
    var paddleX = (canvas.width - paddleWidth) / 2;
    var paddleY = canvas.height - 25;
    var levelSpeedDelta = 1.2;
    var x = canvas.width / 2;
    var y = paddleY - 30;
    var rightPressed = false;
    var leftPressed = false;
    const initialColumns = 5;
    const initialRows = 3;
    var brickRowCount = initialRows;
    var brickColumnCount = initialColumns;
    var brickWidth = 75;
    var brickHeight = 20;
    var brickPadding = 10;
    var brickOffsetTop = 30;
    var brickOffsetLeft = 30;
    var bricks = [];
    var lives = 3; // Number of lives
    var gameRunning = true;
    var gameStarted = false;
    var gameFinished = false;
    var gameReset = false;
    var muteSoundtrack = false;
    var muteAllFX = false;
    var level = 1;
    const initialCountdown = 3;
    var countdown = initialCountdown;
    var ballSpeedOne = 2.5; // life-level, level-level ball speed
    var ballSpeed = ballSpeedOne; // Initial ball speed
    var initialSpeedLimit = 30;
    var speedLimit = initialSpeedLimit;
    var speedLimitGrow = 1.05;
    var initialMaxAngle = 0.7 * Math.PI/2; // max norm deviation tolerated
    var maxAngle = initialMaxAngle;
    var maxAngleGrow = 1.02;
    var initialAngle = Math.PI/4 + (Math.random() * Math.PI/2);
    var dx = ballSpeed/Math.tan(initialAngle)
    var dy = -ballSpeed;
    var acceleration = 5; // in percent-per-paddle-collision
    var paddleSpeed=1.5; // multiplier on the ball speed 
    var colorBricksOne = "#2b8c00";
    var colorBricksTwo = "#0052cc";
    var colorBricksThree = "#b64917";
    if (devMode) {
        lives = 1;
        score = 500;
    }

    // Create the bricks
    for (var c = 0; c < brickColumnCount; c++) {
        bricks[c] = [];
        for (var r = 0; r < brickRowCount; r++) {
            bricks[c][r] = { x: 0, y: 0, status: brickRowCount - r, color: colorBricksOne };
        }
    }


    var tracks = [
        "1_DICE.mp3",
        "3_VOLTA.mp3",
        "4_ASSEMBLY.mp3",
        "6_SINE.mp3",
        "7_FORBIDDEN.mp3",
        "10_BAMBOO.mp3",
        "11_SHIFT.mp3"
    ];

    var tracknames = [
        "Not Playing Dice",
        "Volta",
        "Assembly",
        "Sinusoidal",
        "Forbidden Regions",
        "Bamboo",
        "Shift"
    ];

    var currentTrackIndex = 0;
    var audio = document.getElementById("player")

    async function playNextTrack() {
        // (re)initialize sFX
        
        playFX(paddleHitSrc,true);
        playFX(brickHitSrc,true);
        playFX(brickDestroySrc,true);
        playFX(lostLifeSrc,true);
        
        if (currentTrackIndex >= tracks.length) {
            currentTrackIndex=0;
        }
        audio.src = 'hvgame/' + tracks[currentTrackIndex];
        audio.play();
        ctx.font = "10px Arial";
        ctx.fillStyle = colorBricksOne;
        ctx.textAlign = "center";
        ctx.clearRect(0,canvas.height-10,canvas.width,10)
        ctx.fillText("SONG: MARTIN GERBER - " + tracknames[currentTrackIndex].toUpperCase(), canvas.width / 2, canvas.height);
        currentTrackIndex += 1;
    }

    audio.addEventListener("ended", playNextTrack);

    // Start playing the first track
    //playNextTrack();

    document.addEventListener("keydown", keyDownHandler, false);
    document.addEventListener("keyup", keyUpHandler, false);

    function keyDownHandler(e) {
        if (e.key == "Right" || e.key == "ArrowRight") {
            rightPressed = true;
        } else if (e.key == "Left" || e.key == "ArrowLeft") {
            leftPressed = true;
        }
        if (e.key.toUpperCase() == 'N' && (gameRunning || gameFinished)) {
            playNextTrack();
        }
    }

    function keyUpHandler(e) {
        if (e.key == "Right" || e.key == "ArrowRight") {
            rightPressed = false;
        } else if (e.key == "Left" || e.key == "ArrowLeft") {
            leftPressed = false;
        }
    }

    // Touch event listeners
    document.addEventListener("touchstart", touchStartHandler, false);
    document.addEventListener("touchend", touchEndHandler, false);
    document.addEventListener("touchmove", touchMoveHandler, { passive: false });

    // Disable pinch-to-zoom and double-tap-to-zoom
    document.addEventListener('gesturestart', function (e) {
        e.preventDefault();
    });

    function touchMoveHandler(e) {
        e.preventDefault();
    }

    function touchStartHandler(e) {
        if (!gameStarted) {
            if (!gameReset) {playNextTrack();}
            gameStarted = true;
            draw(); // Start the first draw event
        }
        var touchX = e.changedTouches[0].clientX;
        if (touchX < canvas.width/2) {
            leftPressed = true;
        } else if (touchX >= canvas.width/2) {
            rightPressed = true;
        }
    }

    function touchEndHandler(e) {
        leftPressed = false;
        rightPressed = false;
    }



    function collisionDetection() {
        var ballReflectedVertically = false; // Track if the ball has been reflected vertically
        var ballReflectedHorizontally = false; // Track if the ball has been reflected vertically

        for (var c = 0; c < brickColumnCount; c++) {
            for (var r = 0; r < brickRowCount; r++) {
                var brick = bricks[c][r];
                if (brick.status > 0) {
                    var brickLeft = brick.x;
                    var brickRight = brick.x + brickWidth;
                    var brickTop = brick.y;
                    var brickBottom = brick.y + brickHeight; // THESE ARE INVERTED!!

                    if ( // inside the radius-buffered box, mwg
                        x > brickLeft - ballRadius &&
                        x < brickRight + ballRadius &&
                        y > brickTop - ballRadius &&
                        y < brickBottom + ballRadius
                    ) {
                        brick.status--; // Decrease the hit count

                        if (brick.status === 0) {
                            var points = 10 * level * (brickRowCount - r);
                            score += points;
                            console.log("Brick destroyed:", brick);
                            playFX(brickDestroySrc);
                            console.log("Points earned:", points);
                            console.log("Total Score:", score);
                        } else if (brick.status === 2) {
                            playFX(brickHitSrc);
                            brick.color = colorBricksTwo; // Change to Yellow
                        } else if (brick.status === 1) {
                            playFX(brickHitSrc);
                            brick.color = colorBricksThree; // Change to Red
                        } else if (brick.status > 2) {playFX(brickHitSrc);}

                        // Perform reflection based on the collision side
                        var hitFromTop = false;
                        var hitFromBottom = false;
                        var hitFromLeft = false;
                        var hitFromRight = false;

                        if ( // inside the radius-buffered box, mwg
                            x > brickLeft - ballRadius/2 &&
                            x < brickRight + ballRadius/2 &&
                            y > brickBottom &&
                            y < brickBottom + ballRadius
                        ) {
                            hitFromBottom = true;
                        } else if (x > brickLeft - ballRadius/2 &&
                            x < brickRight + ballRadius/2 &&
                            y > brickTop - ballRadius &&
                            y < brickTop) 
                        {
                            hitFromBottom = true;
                        } else if (x > brickLeft - ballRadius &&
                            x < brickLeft &&
                            y > brickTop - ballRadius/2 &&
                            y < brickBottom + ballRadius/2
                        ) {
                            hitFromLeft = true;
                        } else if (x > brickRight &&
                            x < brickRight + ballRadius &&
                            y > brickTop - ballRadius/2 &&
                            y < brickBottom + ballRadius/2
                        ) {
                            hitFromRight = true;
                        }
                        
                        if ((hitFromTop || hitFromBottom) && !ballReflectedVertically) {
                            // Ball hit from top
                            dy = -dy;
                            ballReflectedVertically = true;
                            hitFromLeft = false;
                            hitFromRight = false;
                        }
                        
                        // Ball hit from left or right
                        if ((hitFromRight || hitFromLeft) && !ballReflectedHorizontally) {
                            // Ball hit from top
                            dx = -dx;
                            ballReflectedHorizontally = true;
                            hitFromTop = false;
                            hitFromBottom = false;
                        } 
                    }
                        
                }
            }
        }

    }



    function drawBall() {
        ctx.beginPath();
        ctx.arc(x, y, ballRadius, 0, Math.PI * 2); //* Math.pow(ballShrink, level - 1)
        ctx.fillStyle = colorBricksOne;
        ctx.fill();
        ctx.closePath();
    }


    function drawPaddle() {
        ctx.beginPath();
        ctx.rect(
            paddleX,
            paddleY - paddleHeight,
            paddleWidth,
            paddleHeight
        );
        ctx.fillStyle = colorBricksOne;
        ctx.fill();
        ctx.closePath();
    }

    function drawBricks() {
        for (var c = 0; c < brickColumnCount; c++) {
            for (var r = 0; r < brickRowCount; r++) {
                var brick = bricks[c][r];
                if (brick.status > 0) {
                    var brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                    var brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                    brick.x = brickX;
                    brick.y = brickY;
                    ctx.beginPath();
                    ctx.rect(brickX, brickY, brickWidth, brickHeight);
                    ctx.fillStyle = brick.color;
                    ctx.fill();
                    ctx.closePath();
                }
            }
        }
    }

    function drawLives() {
        ctx.font = "16px Arial";
        ctx.fillStyle = colorBricksOne;
        ctx.textAlign = "end"; // Align the text to the end position (right)
        ctx.fillText("Lives: " + lives, canvas.width - 10, 20);
    }

    function drawLevel() {
        ctx.font = "16px Arial";
        ctx.fillStyle = colorBricksOne;
        ctx.textAlign = "start"; // Align the text to the start position (left)
        ctx.fillText("Level: " + level, 10, 20);
    }

    function drawScore() {
        ctx.font = "16px Arial";
        ctx.fillStyle = colorBricksOne;
        ctx.textAlign = "center"; // Align the text to the center position
        ctx.fillText("Score: " + score, canvas.width / 2, 20);
    }

    function drawCountdown() {
        ctx.font = "16px Arial";
        ctx.fillStyle = colorBricksOne;
        ctx.textAlign = "start"; // Align the text to the start position
        document.getElementById("player").volume = 1;
        ctx.fillText(
            "Get ready for Level " + level + " in " + countdown,
            canvas.width / 2,
            canvas.height / 2
        );
    }

    function startNextLevel() {
        level++;
        paddleWidth*=paddleShrink;
        speedLimit*=speedLimitGrow;
        maxAngle=Math.min(maxAngleGrow*maxAngle,Math.PI/2);
        resetBall();
        resetPaddle();
        resetBricks();
        countdown = initialCountdown;
        setTimeout(function () {
            draw();
        }, 2000); // Start the game after 5 seconds
    }

    function startNextLife() {
        resetBall();
        resetPaddle();
        countdown = initialCountdown;
        setTimeout(function () {
            draw();
        }, 2000); // Start the game after 5 seconds
    }

    function resetBall() {
        x = canvas.width / 2;
        y = paddleY - 30;

        ballSpeed = ballSpeedOne*Math.pow(levelSpeedDelta, level - 1); // Increase ball speed
        acceleration = acceleration*Math.pow(1.05, level - 1); // Increase ball speed

        console.log(ballSpeed);
        console.log(acceleration);
        
        initialAngle = Math.PI/4 + (Math.random() * Math.PI/2);
        //dx = ballSpeed * Math.cos(initialAngle);
        //dy = -ballSpeed * Math.sin(initialAngle);
        dy = -ballSpeed;
        dx = ballSpeed/Math.tan(initialAngle);
            

        ballRadius *= Math.pow(ballShrink, level - 1); // Decrease ball radius
    }

    function resetPaddle() {
        paddleX = (canvas.width - paddleWidth) / 2;
    }

    function resetBricks() {
        bricks = [];
        brickRowCount = initialRows + level - 1;
        brickColumnCount = initialColumns + level - 1;
        brickWidth = initialColumns / brickColumnCount * 75;
        brickHeight = initialRows / brickRowCount * 20;
        brickPadding = initialColumns / brickColumnCount * 10;

        // Create the bricks
        for (var c = 0; c < brickColumnCount; c++) {
            bricks[c] = [];
            for (var r = 0; r < brickRowCount; r++) {
                bricks[c][r] = { x: 0, y: 0, status: brickRowCount - r, color: colorBricksOne };
            }
        }
        
        for (var c = 0; c < brickColumnCount; c++) {
            for (var r = 0; r < brickRowCount; r++) {
                bricks[c][r].status = brickRowCount - r; // Reset the hit count
                bricks[c][r].color = colorBricksOne; // Reset the color to Blue
            }
        }
    }

    // Declare the gamePaused variable and initialize it as false
    var gamePaused = false;

    // Add an event listener for the space bar keydown event
    document.addEventListener("keydown", function (e) {
    if (e.key === " ") { // Check if the pressed key is the space bar
        if (!gameStarted) {
            if (!gameReset) {playNextTrack();}
            gameStarted = true;
            draw(); // Start the first draw event
        } else if (gameRunning) {
            // Toggle the gamePaused variable
            gamePaused = !gamePaused;
            if (!gameFinished) {
                if (!gamePaused) {
                    draw();
                    document.getElementById("player").play();
                } else {
                    document.getElementById("player").pause();
                }
            }
        }
    }
    });

    function draw() {
        if (!gameStarted) {
            // Display the "PRESS SPACE BAR TO START GAME" prompt
            //playNextTrack();
            ctx.font = "30px Arial";
            ctx.fillStyle = colorBricksOne;
            ctx.textAlign = "center";
            ctx.fillText("TOUCH (SPACE) TO START", canvas.width / 2, canvas.height / 2);
            ctx.font = "16px Arial";
            ctx.textAlign = "left";
            ctx.fillText("R           -   RESTART GAME", canvas.width / 2, canvas.height / 2+40);
            ctx.fillText("N           -   NEXT SONG", canvas.width / 2, canvas.height / 2+60);
            ctx.fillText("M           -   MUTE SOUNDTRACK", canvas.width / 2, canvas.height / 2+80);
            ctx.fillText("S            -   MUTE FX", canvas.width / 2, canvas.height / 2+100);
            ctx.fillText("1 - 7       -   SELECT TRACK", canvas.width / 2, canvas.height / 2+120);
            ctx.fillText("SPACE  -   PAUSE GAME", canvas.width / 2, canvas.height / 2+140);
            return; // Exit the function without updating the game state
        }
        // Check if the game is paused
        if (gamePaused) {
            // Display a message indicating that the game is paused
            ctx.font = "30px Arial";
            ctx.fillStyle = colorBricksOne;
            ctx.textAlign = "center";
            ctx.fillText("PAUSED", canvas.width / 2, canvas.height / 2);
            return; // Exit the function without updating the game state
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBricks();
        drawBall();
        drawPaddle();
        drawLives();
        drawLevel();
        drawScore();
        drawTrackName(); // Call the new function to draw the track name

        if (countdown > 0) {
            drawCountdown();
            countdown--;
            setTimeout(draw, 1000);
            return;
        } else {
            gameRunning = true;
        }

        collisionDetection();

        currentTime = Date.now();
        timeElapsed = (currentTime - previousTime) / 20;  // convert milliseconds to seconds

        if (timeElapsed>5) {timeElapsed=5;}

        console.log(timeElapsed)

        //timeElapsd = Math.max(timeElapsed,1);

        x += dx * timeElapsed * ballSpeed / Math.abs(dy);
        y += Math.sign(dy) * ballSpeed * timeElapsed;

        previousTime = currentTime;

        if (rightPressed && paddleX < canvas.width - paddleWidth) {
            paddleX += paddleSpeed * ballSpeed;
        } else if (leftPressed && paddleX > 0) {
            paddleX -= paddleSpeed * ballSpeed;
        }

        if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
            dx = -dx;
            console.log("Ball hit horizontal wall");
        }
        if (y + dy < ballRadius) {
            dy = -dy;
            console.log("Ball hit vertical wall");
        } else if (y + dy > paddleY - paddleHeight - ballRadius) {
            if (x + dx > paddleX - ballRadius && x + dx < paddleX + ballRadius + paddleWidth) {
                var collisionPoint = x - (paddleX + paddleWidth / 2);
                var angleMag = 30; // Adjust this angle as needed

                // Calculate the reflection angle based on the collision point
                var reflectionAngle = (collisionPoint / (paddleWidth / 2)) * (angleMag * Math.PI / 180);

                // Update the velocity angle while maintaining the speed
                var angle = Math.atan2(dy, dx); // Get the current angle
                console.log("angle in " + angle)

                angle -= reflectionAngle; // Apply the reflection angle
                angle = Math.sign(angle-Math.PI/2)*Math.min(Math.abs(angle-Math.PI/2),maxAngle) + Math.PI/2; // note: theta zero for x>0 y=0
                console.log("angle out " + angle)

                // accelerate the ball
                ballSpeed = Math.min(ballSpeed*(1+acceleration/100),speedLimit);

                // Update the velocity components
                //dx = Math.cos(angle) * ballSpeed; // Update the x-component of velocity
                //dy = -Math.sin(angle) * ballSpeed; // Update the y-component of velocity
                dy = -ballSpeed;
                dx = ballSpeed/Math.tan(angle);
                
                console.log("Ball hit paddle");
                playFX(paddleHitSrc);

            } else {
                if (y > canvas.height - 2*ballRadius) {
                    lives--;
                    playFX(lostLifeSrc);
                    document.getElementById("player").volume = 0.25;
                    if (lives === 0) {
                        console.log("GAME OVER");
                        gameRunning = false;
                        showGameOverText("GAME OVER");
                    } else {
                        gameRunning = false;
                        if (lives>1) {
                            showGameOverText(lives + " LIVES LEFT");
                        } else {
                            showGameOverText(lives + " LIFE LEFT");
                        }
                        setTimeout(startNextLife, 2000);
                    }
                }
            }
        }

        var brickCount = brickRowCount * brickColumnCount;
        var destroyedBrickCount = 0;
        for (var c = 0; c < brickColumnCount; c++) {
            for (var r = 0; r < brickRowCount; r++) {
                if (bricks[c][r].status === 0) {
                    destroyedBrickCount++;
                }
            }
        }
        if (destroyedBrickCount === brickCount) {
            gameRunning = false;
            console.log("YOU WIN");
            showGameOverText("YOU WIN");
            setTimeout(startNextLevel, 2000);
        }

        if (gameRunning) {
            requestAnimationFrame(draw);
        }
    }

    function drawTrackName() {
        ctx.font = "14px Arial";
        ctx.fillStyle = colorBricksOne;
        ctx.textAlign = "center";
        ctx.fillText("SONG: MARTIN GERBER - " + tracknames[currentTrackIndex-1].toUpperCase(), canvas.width / 2, canvas.height);
    }

    async function dispScoreboard() {
        gameFinished = true;
        // Display the top scores
        ctx.font = "20px Arial";
        const yOffset=25;
        ctx.fillText("TOP SCORES", canvas.width / 2, canvas.height / 2 + yOffset - 25);
        ctx.font = "16px Arial";
        ctx.textAlign = "start"; 
        for (let i = 0; i < 5; i++) { 
            if (i<topNames.length) {
                ctx.fillText(i+1+") "+topNames[i].substring(0,11)+":", 25, canvas.height / 2 + yOffset + (20*i));
                ctx.fillText(topScores[i], 175, canvas.height / 2 + yOffset + (20*i));
            } else {
                ctx.fillText(i+1+") -----:", 25, canvas.height / 2 + yOffset + (20*i));
                ctx.fillText("0", 175, canvas.height / 2 + yOffset + (20*i));
            }
        }
        for (let i = 5; i < 10; i++) { 
            if (i<topNames.length) {
                ctx.fillText(i+1+") "+topNames[i].substring(0,11)+":", canvas.width / 2 + 50, canvas.height / 2 + yOffset + (20*(i-5)));
                ctx.fillText(topScores[i], canvas.width / 2 + 50 + 150, canvas.height / 2 + yOffset + (20*(i-5)));
            } else {
                ctx.fillText(i+1+") -----:", canvas.width / 2 + 50, canvas.height / 2 + yOffset + (20*(i-5)));
                ctx.fillText("0", canvas.width / 2 + 50 + 150, canvas.height / 2 + yOffset + (20*(i-5)));
            }
        }
        
    }

    async function showGameOverText(text) {
        
        ctx.font = "48px Arial";
        ctx.fillStyle = colorBricksOne;
        ctx.textAlign = "center";
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        ctx.font = "24px Arial";
        ctx.fillText("Score: " + score, canvas.width / 2, canvas.height / 2 + 30);
        
        if (!isMobile) {
            if (text === "GAME OVER") {
                setTimeout(function(){document.getElementById("player").volume = 1;},3000);
            if (score > oldTopScore) {
                if (score > oldHighScore) {
                    ctx.fillText("NEW HIGH SCORE!", canvas.width / 2, canvas.height / 2 + 60);
                } else {
                    ctx.fillText("YOU MADE THE TOP-TEN!", canvas.width / 2, canvas.height / 2 + 60);
                }
                
                ctx.fillText("TYPE NAME & PRESS ENTER", canvas.width / 2, canvas.height / 2 + 90);
            
                var cursorVisible = true;
                var cursorBlinkInterval;
                var highScoreAddressEntered = false; // Flag to indicate if the wallet address has been entered
                var stage = "name";
            
            
                // Start the cursor blinking
                cursorBlinkInterval = setInterval(blinkCursor, 500);
            
                // Listen for keydown events to capture the player's name input
                document.addEventListener("keydown", keyDownHandler, false);
            
                // Draw the player's name and cursor
                drawPlayerName();
            
                async function keyDownHandler(e) {
                    if (!highScoreAddressEntered) {
                        // Handle player name input
                        if (e.key === "Enter") {
                            if (playerName) {
                            // Player submitted the name
                            console.log("Player Name:", playerName);
                            // Perform further processing with the playerName variable
                
                            // Clear the name prompt text
                            ctx.clearRect(
                                0,
                                canvas.height/2,
                                1000,
                                canvas.height/2-10
                            );
                
                            stage = "address";
                            // Update the text for the wallet address prompt
                            ctx.fillText(
                                "PASTE WALLET ADDRESS TO WIN PRIZE",
                                canvas.width / 2,
                                canvas.height / 2 + 50
                            );
    
                            ctx.fillText(
                                "ADDRESS WILL NOT BE DISPLAYED ON SCOREBOARD",
                                canvas.width / 2,
                                canvas.height / 2 + 70
                            );
    
                            ctx.fillText(
                                "PRESS ENTER TO SUBMIT OR SKIP",
                                canvas.width / 2,
                                canvas.height / 2 + 90
                            );
                
                            highScoreAddressEntered = true; // escapes this function
                            stage="final";
                            
                            }
                        } else if (e.key === "Backspace") {
                            // Handle the backspace key
                            e.preventDefault(); // Prevent the default backspace behavior
                
                            if (playerName.length > 0) {
                            playerName = playerName.slice(0, -1);
                            drawPlayerName();
                            }
                        } else if (e.key.length === 1 && e.key !== "v" && !e.ctrlKey && !e.metaKey) {
                            // Capture alphanumeric characters (excluding "v" when used with Ctrl or Command)
                            if (playerName.length<11) {
                                playerName += (e.key).toUpperCase();
                            }
                            drawPlayerName();
                        }
                    } else if (!gameFinished) {
                    // Handle wallet address input
                        if (e.key === "Enter") {
                            if (!highScoreAddress) {
                                highScoreAddress="";
                            }
                            console.log("Wallet Address:", highScoreAddress);
                            // Perform further processing with the highScoreAddress variable
                            if (e.key === "Enter") {
                                // Clear the screen
                                ctx.clearRect(0, 0, canvas.width, canvas.height-10);
                        
                                // Display the "Thank you" message
                                ctx.font = "30px Arial";
                                ctx.fillStyle = colorBricksOne;
                                ctx.textAlign = "center"; // Align the text to the center position
                                ctx.fillText("THANK YOU FOR PLAYING!!", canvas.width / 2, canvas.height / 2 - 100);
                                ctx.font = "24px Arial";
                                addScore().then(() => getTopScores()).then(() => dispScoreboard());
                                ctx.fillText("SCORE ("+score+") SUBMITTED!", canvas.width / 2, canvas.height / 2 - 60);
                                ctx.fillText("REFRESH TO PLAY AGAIN", canvas.width / 2, canvas.height / 2 - 35);
                                
                            }
                            
                        } else if (e.key === "Backspace") {
                            // Handle the backspace key
                            e.preventDefault(); // Prevent the default backspace behavior
                
                            if (highScoreAddress.length > 0) {
                            highScoreAddress = highScoreAddress.slice(0, -1);
                            drawWalletAddress();
                            }
                        } else if (e.key.length === 1 && e.key !== "v" && !e.ctrlKey && !e.metaKey) {
                            // Capture alphanumeric characters (excluding "v" when used with Ctrl or Command)
                            highScoreAddress += e.key;
                            drawWalletAddress();
                        }
                    }
                }
            
                // Listen for the paste event
                document.addEventListener("paste", function (e) {
                    e.preventDefault();
                    var clipboardData = e.clipboardData || window.clipboardData;
                    var pastedText = clipboardData.getData("text");
                    if (!highScoreAddressEntered) {
                        playerName += pastedText;
                        console.log('drawPlayerName')
                        drawPlayerName();
                    } else {
                        highScoreAddress += pastedText;
                        console.log('drawWalletAddress')
                        drawWalletAddress();
                    }
                });
            
                function drawPlayerName() {
                    ctx.clearRect(
                    0,
                    canvas.height - 60,
                    1000,
                    50
                    );
            
                    ctx.font = "16px Arial";
                    ctx.fillStyle = colorBricksOne;
                    ctx.textAlign = "center";
                    ctx.fillText(playerName, canvas.width / 2, canvas.height / 2 + 120);
            
                    if (cursorVisible) {
                    ctx.beginPath();
                    ctx.moveTo(
                        canvas.width / 2 + playerName.length * 6,
                        canvas.height / 2 + 100
                    );
                    ctx.lineTo(
                        canvas.width / 2 + playerName.length * 6,
                        canvas.height / 2 + 120
                    );
                    ctx.strokeStyle = colorBricksOne;
                    ctx.stroke();
                    ctx.closePath();
                    }
                }
            
                function drawWalletAddress() {
                    ctx.clearRect(
                        0,
                        canvas.height - 60,
                        1000,
                        50
                    ); // Clear previous text and cursor
            
                    ctx.font = "16px Arial";
                    ctx.fillStyle = colorBricksOne;
                    ctx.textAlign = "center";
                    ctx.fillText(
                    highScoreAddress,
                    canvas.width / 2,
                    canvas.height / 2 + 120
                    );
            
                    if (cursorVisible) {
                        ctx.beginPath();
                        ctx.moveTo(
                        canvas.width / 2 + highScoreAddress.length * 6,
                        canvas.height / 2 + 100
                        );
                        ctx.lineTo(
                        canvas.width / 2 + highScoreAddress.length * 6,
                        canvas.height / 2 + 120
                        );
                        ctx.strokeStyle = colorBricksOne;
                        ctx.stroke();
                        ctx.closePath();
                    }
                }
            
                function blinkCursor() {
                    cursorVisible = !cursorVisible;
                    if (stage=="name"){drawPlayerName();};
                    if (stage=="address"){drawWalletAddress();};
                }
            } else {
                // Clear the screen
                ctx.clearRect(0, 0, canvas.width, canvas.height - 10);
                            
                // Display the "Thank you" message
                ctx.font = "30px Arial";
                ctx.fillStyle = colorBricksOne;
                ctx.textAlign = "center"; // Align the text to the center position
                ctx.fillText("GAME OVER: "+score, canvas.width / 2, 40);
                ctx.font = "24px Arial";
                ctx.fillText("THANK YOU FOR PLAYING!", canvas.width / 2, 75);
                ctx.fillText("GET A HIGH SCORE TO WIN", canvas.width / 2, 100);
                ctx.fillText("WEEKLY GIVEAWAYS", canvas.width / 2, 125);
                ctx.fillText("REFRESH BROWSER TO TRY AGAIN", canvas.width / 2, canvas.height-20);
    
                dispScoreboard();
            }
            }
        } else {
            // Mobile handling

            if (text === "GAME OVER") {
                ctx.clearRect(0,0,canvas.width,canvas.height-10);
                if (score > oldTopScore){
                    playerName = window.prompt("Submit score! name:").toUpperCase();
                    highScoreAddress = window.prompt("Enter your wallet address (to win):");
                }
                
                // Display the "Thank you" message
                ctx.font = "30px Arial";
                ctx.fillStyle = colorBricksOne;
                ctx.textAlign = "center"; // Align the text to the center position
                ctx.fillText("GAME OVER: "+score, canvas.width / 2, 40);
                ctx.fillText("THANK YOU FOR PLAYING!!", canvas.width / 2, canvas.height / 2 - 85);
                ctx.font = "24px Arial";
                if (score > oldTopScore){
                    addScore().then(() => getTopScores()).then(() => dispScoreboard());
                    ctx.fillText("SCORE ("+score+") SUBMITTED!", canvas.width / 2, canvas.height / 2 - 60);
                }
                ctx.fillText("REFRESH TO PLAY AGAIN", canvas.width / 2, canvas.height / 2 - 35);
                dispScoreboard();
            }
            
        }
    }

    document.addEventListener("keydown", function (e) {
        if (e.key.toUpperCase() == 'R' && (gameRunning || gameFinished) && countdown == 0) {
            restartGame();
        }
        if (e.key.toUpperCase() == "M") {
            if (!muteSoundtrack) {
                audio.volume = 0;
            } else {
                audio.volume = 1;
            }
            muteSoundtrack = !muteSoundtrack;
        }
        if (e.key.toUpperCase() == "S") {
            muteAllFX = !muteAllFX;
        }
        if (e.key == 1) {
            currentTrackIndex = 0;
            playNextTrack();
        }
        if (e.key == 2) {
            currentTrackIndex = 1;
            playNextTrack();
        }
        if (e.key == 3) {
            currentTrackIndex = 2;
            playNextTrack();
        }
        if (e.key == 4) {
            currentTrackIndex = 3;
            playNextTrack();
        }
        if (e.key == 5) {
            currentTrackIndex = 4;
            playNextTrack();
        }
        if (e.key == 6) {
            currentTrackIndex = 5;
            playNextTrack();
        }
        if (e.key == 7) {
            currentTrackIndex = 6;
            playNextTrack();
        }
    });

    async function restartGame() {
        ballRadius = 10;
        paddleWidth = 125;
        paddleX = (canvas.width - paddleWidth) / 2;
        x = canvas.width / 2;
        y = paddleY - 30;
        rightPressed = false;
        leftPressed = false;
        brickRowCount = initialRows;
        brickColumnCount = initialColumns;
        brickWidth = 75;
        brickHeight = 20;
        brickPadding = 10;
        brickOffsetTop = 30;
        brickOffsetLeft = 30;
        bricks = [];
        lives = 3; // Number of lives
        gameRunning = true;
        gameStarted = false;
        gameFinished = false;
        gameReset = true;
        level = 1;
        countdown = initialCountdown;
        ballSpeed = ballSpeedOne; // Initial ball speed
        speedLimit = initialSpeedLimit;
        maxAngle = initialMaxAngle;
        initialAngle = Math.PI/4 + (Math.random() * Math.PI/2);
        dx = ballSpeed/Math.tan(initialAngle)
        dy = -ballSpeed;
        acceleration = 5; // in percent-per-paddle-collision
        score = 0;

        // Create the bricks
        for (var c = 0; c < brickColumnCount; c++) {
            bricks[c] = [];
            for (var r = 0; r < brickRowCount; r++) {
                bricks[c][r] = { x: 0, y: 0, status: brickRowCount - r, color: colorBricksOne };
            }
        }

        ctx.clearRect(0,0,canvas.width,canvas.height);
        draw();
    }

        
    draw();
  </script>
</body>
</html>